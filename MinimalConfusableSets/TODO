Would be nice to have these iterators start from an arbitrary point.

I now realised that the iterators as currently made are wasteful in that they only treat "permable" and "not permable" whereas within the permable section, there will be some parts that are less permable than others. E.g.

AB.BBCDDE......
.B..BDDDEAB....

should not be treated as is the fist 10 cells are completely distinct just because they have been filled

ABCDEFGHIJK....

but rather as

AB.xByDDEzw....

since though all the first cels are filled, they are not all indistinguishable. On the contrary, the second column (BB) is the same as the 5th column (BB) and so these cannot be distinguished and do not therefore need perming among themselves. We therefore need to keep track not of the number of filled spaces (as at present) but rather need to report a set of classes where two positions are equivalent iff they have the same label.

The structure which shall record the equivalence classes shall be iterable, having one element per equivalence class of locations.
Each element shall  be an iterable containing the locatons which are eqilalent.
E.g. if the list is

Cabbage   # This is the word
0123456   # (this is just a ruler I put below the word)

then a suitable equivalence class representer for "Cabbage" might d.values() for this dictionary:

 d = {
  "a" : (1,4,),
  "b" : (2,3,),
  "C" : (0,),
  "g" : (5,),
  "e" : (6,)
 }

since d.values() would return iter(((1,4), (2,3), (0,), (5,), (6,) ))

=====================================

The above is now implemented in vertex_matches.generate_all_vertex_matches_given_equivalent_places().  However the implementation is a bit hacky and does not use distinct_permutations at all, let alone the r=r partial part of it!
